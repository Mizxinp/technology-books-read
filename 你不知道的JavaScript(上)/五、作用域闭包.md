# 作用域闭包

- 当函数可以记住并访问所在的词法作用域时，就产生了闭包

典型例子：

```javascript
function foo() {
  var a = 2
  function bar() {
    console.log(a)
  }
  return bar
}
var baz = foo()
baz() // 2
```

- 由于bar()所声明的位置在foo内部，所以它拥有涵盖foo内部作用域的闭包，使得该作用域能够一直存活
- bar()依然持有对该作用域的引用，而这个引用就叫做闭包
- bar()这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域
- 无论使用何种方式对函数的值进行传递，但函数在别处被调用时都可以观察到闭包。即无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包

本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一级的值类型并导出传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是使用了闭包

### 循环和闭包

```javascript
for(var i=1; i<5; i++) {
  setInterval(function timer() {
    console.log(i)
  }, i*1000)
}
```

循环的每一次迭代不会给自己“捕获”一个i的副本。尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都**被封闭在一个共享的全局作用域中，因此实际上只用一个i**

#### 快作用域

let声明可以用来劫持块作用域，并且在这个块作用域中声明一个变量。本质上这是一个块转换成一个可以被关闭的作用域。

其实for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量